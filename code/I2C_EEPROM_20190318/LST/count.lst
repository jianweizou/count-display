C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE COUNT
OBJECT MODULE PLACED IN .\Output\count.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE Code\count.c COMPACT ROM(COMPACT) OPTIMIZE(8,SIZE) BROWSE INCDIR(..\..\Incl
                    -ude;..\Include) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\count.lst) TABS(2) OBJECT(.\Output\count.obj)

line level    source

   1          #include "N76E003.h"
   2          #include "SFR_Macro.h"
   3          #include "count.h"
   4          #include "fontdata.h"
   5          #include "Function_define.h"
   6          #include "OLED.h"
   7          #include "dataflash.h"
   8          #include "ds1302.h"
   9          extern void Timer0_Init(void);
  10          extern void Timer1_Delay10ms(unsigned long cnt);
  11          extern void Erase_LDROM(unsigned int datasize,unsigned int dataaddr);
  12          #define POWER_WAKEUP  1
  13          #if POWER_WAKEUP
  14          #define KEYINPUTMODE  P17_Input_Mode;P30_Input_Mode;P04_Input_Mode
  15          #else
              #define KEYINPUTMODE  P17_Input_Mode
              #endif
  18          #define GETKEY    P17
  19          
  20          unsigned char stage_loopcnt = 0;
  21          
  22          SysStruct sysinfo;
  23          KEYTYPE keytype;
  24          unsigned char curKey,preKey;
  25          unsigned char debounce;
  26          unsigned char islongpress;
  27          unsigned char is_5ms_Flag;
  28          unsigned char blinktime;
  29          unsigned int powercnt;
  30          
  31          
  32          
  33          
  34          
  35          #define TH0_INIT        (65536-6667)/256 //5.0ms@XTAL=12MHz, Period = (10.85/2) ms@XTAL=22.1184MHz
  36          #define TL0_INIT        (65536-6667)%256
  37          #define TH1_INIT        0xE0 //2.5ms@XTAL=12MHz, Period = (5.425/2) ms@XTAL=22.1184MHz
  38          #define TL1_INIT        0x00
  39          
  40          bit BIT_TMP;
  41          
  42          extern unsigned char is_5ms_Flag;
  43          extern unsigned char blinktime;
  44          extern unsigned int powercnt;
  45          extern SysStruct  sysinfo;
  46          extern unsigned char get_battery_time;
  47          /*********************************************************************************************************
             -***
  48          *    TIMER 0 interrupt subroutine
  49          **********************************************************************************************************
             -**/
  50          void Timer0_ISR (void) interrupt 1          //interrupt address is 0x000B
  51          {
  52   1          TH0 = TH0_INIT;
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 2   

  53   1          TL0 = TL0_INIT;
  54   1        is_5ms_Flag = 1;
  55   1        blinktime++;
  56   1        if (blinktime > (BLINK_H+BLINK_L))
  57   1          blinktime = 0;
  58   1        powercnt++;
  59   1        get_battery_time++;
  60   1      }
  61          
  62          void Timer0_Init(void)
  63          {
  64   1        TMOD = 0XFF;
  65   1        TIMER0_MODE1_ENABLE;                        //Timer 0  mode configuration
  66   1          
  67   1        clr_T0M;
  68   1          
  69   1        TH0 = TH0_INIT;
  70   1        TL0 = TL0_INIT;
  71   1          
  72   1        set_ET0;                                    //enable Timer0 interrupt
  73   1        set_EA;                                     //enable interrupts
  74   1        
  75   1        set_TR0;                                    //Timer0 run
  76   1      }
  77          
  78          #define UART_TEST 1
  79          
  80          #if UART_TEST
  81          
  82          /*******************************/
  83          typedef unsigned char         UINT8;
  84          typedef unsigned int          UINT16;
  85          typedef unsigned long         UINT32;
  86          
  87          typedef unsigned char         uint8_t;
  88          typedef unsigned int          uint16_t;
  89          typedef unsigned long         uint32_t;
  90          /*uart1*/
  91          void InitialUART1_Timer3(UINT32 u32Baudrate) //use timer3 as Baudrate generator
  92          {
  93   1          P02_Quasi_Mode;   //Setting UART pin as Quasi mode for transmit
  94   1          P16_Quasi_Mode;   //Setting UART pin as Quasi mode for transmit
  95   1        
  96   1          SCON_1 = 0x50;    //UART1 Mode1,REN_1=1,TI_1=1
  97   1          T3CON = 0x08;     //T3PS2=0,T3PS1=0,T3PS0=0(Prescale=1), UART1 in MODE 1
  98   1          clr_BRCK;
  99   1        
 100   1      #ifdef FOSC_160000
 101   1          RH3    = HIBYTE(65536 - (1000000/u32Baudrate)-1);     /*16 MHz */
 102   1          RL3    = LOBYTE(65536 - (1000000/u32Baudrate)-1);     /*16 MHz */
 103   1      #endif
 104   1      #ifdef FOSC_166000
                  RH3    = HIBYTE(65536 - (1037500/u32Baudrate));       /*16.6 MHz */
                  RL3    = LOBYTE(65536 - (1037500/u32Baudrate));       /*16.6 MHz */
              #endif
 108   1          set_TR3;         //Trigger Timer3
 109   1      }
 110          UINT8 Receive_Data_From_UART1(void)
 111          {
 112   1          UINT8 c;
 113   1          
 114   1          while (!RI_1);
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 3   

 115   1          c = SBUF_1;
 116   1          RI_1 = 0;
 117   1          return (c);
 118   1      }
 119          
 120          void Send_Data_To_UART1 (UINT8 c)
 121          {
 122   1          TI_1 = 0;
 123   1          SBUF_1 = c;
 124   1          while(TI_1==0);
 125   1      }
 126          char putchar (char c)
 127          {
 128   1          while (!TI_1);  /* wait until transmitter ready */
 129   1          TI_1 = 0;
 130   1          SBUF_1 = c;      /* output character */
 131   1          return (c);
 132   1      }
 133          
 134          void Timer1_Delay100us(unsigned long cnt)
 135          {
 136   1          clr_T1M;                                    //T1M=0, Timer1 Clock = Fsys/12
 137   1          TMOD |= 0x10;                               //Timer1 is 16-bit mode
 138   1          set_TR1;                                    //Start Timer1
 139   1          while (cnt != 0)
 140   1          {
 141   2              TL1 = LOBYTE(TIMER_DIV12_VALUE_100us);    //Find  define in "Function_define.h" "TIMER VALUE"
 142   2              TH1 = HIBYTE(TIMER_DIV12_VALUE_100us);
 143   2              while (TF1 != 1);                       //Check Timer1 Time-Out Flag
 144   2              clr_TF1;
 145   2              cnt --;
 146   2          }
 147   1          clr_TR1;                                    //Stop Timer1
 148   1      }
 149          #endif
 150          
 151          #if POWER_WAKEUP
 152          unsigned char power_debounce;
 153          bit  is_enter_charging;
 154          unsigned char las_stage;
 155          #endif
 156          #define BAT_LEVEL_0 3500
 157          #define BAT_LEVEL_1 3700
 158          #define BAT_LEVEL_2 3900
 159          
 160          unsigned char bat_change_cnt=0;
 161          unsigned char batlevel=0xFF;
 162          unsigned char bat_charging_level;
 163          bit isdisplaybaticon = 0;
 164          extern bit BIT_TMP;
 165          
 166          unsigned char ischangebatlevel_cnt = 0;
 167          unsigned char get_battery_time = 0;
 168          
 169          void KeyInit(void)
 170          {
 171   1        curKey = 0;
 172   1        preKey = 1;
 173   1        debounce = 0;
 174   1        islongpress = 0;
 175   1        keytype = 0;
 176   1        KEYINPUTMODE;
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 4   

 177   1        
 178   1        //
 179   1        #if POWER_WAKEUP
 180   1        power_debounce = 0;
 181   1        is_enter_charging = 0;
 182   1        #endif
 183   1      }
 184          
 185          void KeyScan(void)
 186          {
 187   1        if (is_5ms_Flag)
 188   1        {
 189   2          is_5ms_Flag = 0;
 190   2          curKey = GETKEY;
 191   2          if (curKey != preKey)
 192   2          {
 193   3            preKey = curKey;
 194   3            if ((islongpress == 0)&&(debounce > 10))
 195   3            {
 196   4              keytype = SHORTKEY;
 197   4            }
 198   3            debounce = 0;
 199   3            islongpress = 0;
 200   3            
 201   3            powercnt = 0;
 202   3          }
 203   2          else if(curKey == 0)
 204   2          {
 205   3            debounce++;
 206   3            if (debounce >= 200)
 207   3            {
 208   4              debounce = 0;
 209   4              islongpress++;
 210   4              if (islongpress >= 10)
 211   4              {
 212   5                keytype = LONGKEY_12S;
 213   5              }
 214   4              else if (islongpress >= 5)
 215   4              {
 216   5                keytype = LONGKEY_5S;
 217   5              }
 218   4              else if (islongpress >= 2)
 219   4              {
 220   5                keytype = LONGKEY_2S;
 221   5              }
 222   4            }
 223   3            powercnt = 0;
 224   3          }
 225   2          #if POWER_WAKEUP
 226   2          //5v power check
 227   2          if (P30 == 0)
 228   2          {
 229   3            power_debounce = 0;
 230   3            if (is_enter_charging == 1)
 231   3            {
 232   4              is_enter_charging = 0;
 233   4              sysinfo.sysloop = las_stage;
 234   4              sysinfo.isneedinitstage = 1;
 235   4              OLED_CLS_Windows(16,1,48,3);
 236   4            }
 237   3          }
 238   2          else
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 5   

 239   2          {
 240   3            powercnt = 0;
 241   3            power_debounce++;
 242   3            if (power_debounce > 10)
 243   3            {
 244   4              //enter power charging
 245   4              power_debounce = 10;
 246   4              if (is_enter_charging == 0)
 247   4              {
 248   5                is_enter_charging = 1;
 249   5                las_stage = sysinfo.sysloop;
 250   5                sysinfo.sysloop = SYS_CHARGE;
 251   5                sysinfo.isneedinitstage = 1;
 252   5              }
 253   4            }
 254   3          }
 255   2          #endif
 256   2        }
 257   1      }
 258          
 259          void display_Language_chinese(unsigned char isdisplay,unsigned char inverse)
 260          {
 261   1        if (isdisplay == 1)
 262   1        {
 263   2          Draw_BMP(16,2,16+16,4,(unsigned char *)font_CHN_ZHONG,inverse);
 264   2          Draw_BMP(32,2,32+16,4,(unsigned char *)font_CHN_WEN,inverse);
 265   2        }
 266   1        else
 267   1        {
 268   2          OLED_CLS_Windows(16,2,48,4);
 269   2        }
 270   1      }
 271          void display_Language_english(unsigned char isdisplay,unsigned char inverse)
 272          {
 273   1        if (isdisplay == 1)
 274   1        {
 275   2          Draw_BMP(4,0,12,2,(unsigned char *)font_E,inverse);
 276   2          Draw_BMP(12,0,20,2,(unsigned char *)font_N,inverse);
 277   2          Draw_BMP(20,0,28,2,(unsigned char *)font_G,inverse);
 278   2          Draw_BMP(28,0,36,2,(unsigned char *)font_L,inverse);
 279   2          Draw_BMP(36,0,44,2,(unsigned char *)font_I,inverse);
 280   2          Draw_BMP(44,0,52,2,(unsigned char *)font_S,inverse);
 281   2          Draw_BMP(52,0,60,2,(unsigned char *)font_H,inverse);
 282   2        }
 283   1        else
 284   1        {
 285   2          OLED_CLS_Windows(4,0,60,2);
 286   2        }
 287   1      }
 288          void Select_Language(void)
 289          {
 290   1        if (sysinfo.isneedinitstage == 1)
 291   1        {
 292   2          sysinfo.isneedinitstage = 0;
 293   2          //init 
 294   2          OLED_CLS_Windows(12,1,52,3);
 295   2          display_Language_chinese(1,0);
 296   2          display_Language_english(1,1);    
 297   2          stage_loopcnt = ENGLISH;
 298   2          while(GETKEY == 0);
 299   2        }
 300   1        if (keytype != NULLKEY)
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 6   

 301   1        {
 302   2          if (keytype == SHORTKEY)
 303   2          {
 304   3            if (stage_loopcnt == CHINESE)
 305   3            {
 306   4              display_Language_chinese(1,0);
 307   4              display_Language_english(1,1);  
 308   4              stage_loopcnt = ENGLISH;
 309   4            }
 310   3            else
 311   3            {
 312   4              display_Language_chinese(1,1);
 313   4              display_Language_english(1,0);  
 314   4              stage_loopcnt = CHINESE;  
 315   4            }
 316   3            sysinfo.language = stage_loopcnt;
 317   3          }
 318   2          else if (keytype >= LONGKEY_2S)
 319   2          {
 320   3            sysinfo.language = stage_loopcnt;
 321   3            sysinfo.sysloop = SELECT_NUMTYPE;
 322   3            stage_loopcnt = 0;
 323   3            sysinfo.isneedinitstage = 1;
 324   3            display_Language_english(0,0);
 325   3            display_Language_chinese(0,0);
 326   3          }
 327   2          keytype = NULLKEY;
 328   2        }
 329   1      }
 330          
 331          
 332          unsigned int getdiv(unsigned long x,unsigned long y)
 333          {
 334   1        unsigned int div = 0;
 335   1        while(x >= y)
 336   1        {
 337   2          div++;
 338   2          x = x - y;
 339   2        }
 340   1        return div;
 341   1      }
 342          unsigned int getremainder(unsigned long x,unsigned long y)
 343          {
 344   1        while(x >= y)
 345   1        {
 346   2          x = x - y;
 347   2        }
 348   1        return x;
 349   1      }
 350          
 351          void display_cnt_stage_arabnum(unsigned char isdisplay,unsigned char inverse)
 352          {
 353   1      //  char * nor = "NORMAL";
 354   1      //  char i;
 355   1        if (sysinfo.language == ENGLISH)
 356   1        {
 357   2          if (isdisplay == 1)
 358   2          {
 359   3      //      for (i=0;i<6;i++)
 360   3      //      {
 361   3      //        Draw_BMP(8 + i*8,0,8+8 + i*8,2,font_A_Z + (nor[i] - 'A')*16);
 362   3      //      }
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 7   

 363   3            Draw_BMP(8,0,16,2,(unsigned char *)font_N,inverse);
 364   3            Draw_BMP(16,0,24,2,(unsigned char *)font_O,inverse);
 365   3            Draw_BMP(24,0,32,2,(unsigned char *)font_R,inverse);
 366   3            Draw_BMP(32,0,40,2,(unsigned char *)font_M,inverse);
 367   3            Draw_BMP(40,0,48,2,(unsigned char *)font_A,inverse);
 368   3            Draw_BMP(48,0,56,2,(unsigned char *)font_L,inverse);
 369   3          }
 370   2          else
 371   2          {
 372   3            OLED_CLS_Windows(8,0,56,2);
 373   3          }   
 374   2        }
 375   1        else
 376   1        {
 377   2          if (isdisplay == 1)
 378   2          {
 379   3            Draw_BMP(16,0,16+16,2,(unsigned char *)font_CHN_SHU,inverse);
 380   3            Draw_BMP(32,0,32+16,2,(unsigned char *)font_CHN_ZI,inverse);
 381   3          }
 382   2          else
 383   2          {
 384   3            OLED_CLS_Windows(16,0,48,2);
 385   3          }
 386   2        }
 387   1      }
 388          void display_cnt_stage_tibnum(unsigned char isdisplay,unsigned char inverse)
 389          { 
 390   1      //  char * nor = "TIBETAN";
 391   1      //  char i;
 392   1        if (sysinfo.language == ENGLISH)
 393   1        {
 394   2          if (isdisplay == 1)
 395   2          {
 396   3      //      for (i=0;i<7;i++)
 397   3      //      {
 398   3      //        Draw_BMP(4+ i*8,2,8+4+ i*8,4,font_A_Z + (nor[i] - 'A')*16);
 399   3      //      }
 400   3            Draw_BMP(4,2,12,4,(unsigned char *)font_T,inverse);
 401   3            Draw_BMP(12,2,20,4,(unsigned char *)font_I,inverse);
 402   3            Draw_BMP(20,2,28,4,(unsigned char *)font_B,inverse);
 403   3            Draw_BMP(28,2,36,4,(unsigned char *)font_E,inverse);
 404   3            Draw_BMP(36,2,44,4,(unsigned char *)font_T,inverse);
 405   3            Draw_BMP(44,2,52,4,(unsigned char *)font_A,inverse);
 406   3            Draw_BMP(52,2,60,4,(unsigned char *)font_N,inverse);
 407   3          }
 408   2          else
 409   2          {
 410   3            OLED_CLS_Windows(4,2,60,4);
 411   3          }   
 412   2        }
 413   1        else
 414   1        {
 415   2          if (isdisplay == 1)
 416   2          {
 417   3            Draw_BMP(0,2,0+16,4,(unsigned char *)font_CHN_ZANG,inverse);
 418   3            Draw_BMP(16,2,16+16,4,(unsigned char *)font_CHN_WEN,inverse);   
 419   3            Draw_BMP(32,2,16+32,4,(unsigned char *)font_CHN_SHU,inverse);
 420   3            Draw_BMP(48,2,48+16,4,(unsigned char *)font_CHN_ZI,inverse);
 421   3          }
 422   2          else
 423   2          {
 424   3            OLED_CLS_Windows(0,2,64,4);
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 8   

 425   3          }
 426   2        }
 427   1      }
 428          void Select_NumType(void)
 429          {
 430   1        if (sysinfo.isneedinitstage == 1)
 431   1        {
 432   2          sysinfo.isneedinitstage = 0;
 433   2          display_cnt_stage_arabnum(1,1);
 434   2          display_cnt_stage_tibnum(1,0);
 435   2          stage_loopcnt = ARABNUM;
 436   2          while(GETKEY == 0);
 437   2        } 
 438   1        if (keytype != NULLKEY)
 439   1        {
 440   2          if (keytype == SHORTKEY)
 441   2          {
 442   3            if (stage_loopcnt == TIBENUM)
 443   3            {
 444   4              display_cnt_stage_arabnum(1,1);
 445   4              display_cnt_stage_tibnum(1,0);
 446   4              stage_loopcnt = ARABNUM;
 447   4            }
 448   3            else
 449   3            {
 450   4              display_cnt_stage_arabnum(1,0);
 451   4              display_cnt_stage_tibnum(1,1);
 452   4              stage_loopcnt = TIBENUM;
 453   4            }
 454   3            sysinfo.numtype = stage_loopcnt;
 455   3          }
 456   2          else if (keytype >= LONGKEY_2S)
 457   2          {
 458   3            sysinfo.sysloop = CNT_STAGE;
 459   3            sysinfo.numtype = stage_loopcnt;
 460   3            stage_loopcnt = 0;
 461   3            sysinfo.isneedinitstage = 1;
 462   3            display_cnt_stage_arabnum(0,0);
 463   3            display_cnt_stage_tibnum(0,0);      
 464   3          }
 465   2          keytype = NULLKEY;
 466   2        }
 467   1      }
 468          
 469          
 470          void display_ARA(unsigned char start,unsigned char startline,unsigned char end,unsigned char endline, unsi
             -gned char index,unsigned char inverse)
 471          {
 472   1        if (index == 0)
 473   1        {
 474   2          Draw_BMP(start,startline,end,endline,(unsigned char*)font0,inverse);
 475   2        }
 476   1        else if (index == 1)
 477   1        {
 478   2          Draw_BMP(start,startline,end,endline,(unsigned char*)font1,inverse);
 479   2        }
 480   1        else if (index == 2)
 481   1        {
 482   2          Draw_BMP(start,startline,end,endline,(unsigned char*)font2,inverse);
 483   2        }
 484   1        else if (index == 3)
 485   1        {
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 9   

 486   2          Draw_BMP(start,startline,end,endline,(unsigned char*)font3,inverse);
 487   2        }
 488   1        else if (index == 4)
 489   1        {
 490   2          Draw_BMP(start,startline,end,endline,(unsigned char*)font4,inverse);
 491   2        }
 492   1        else if (index == 5)
 493   1        {
 494   2          Draw_BMP(start,startline,end,endline,(unsigned char*)font5,inverse);
 495   2        }
 496   1        else if (index == 6)
 497   1        {
 498   2          Draw_BMP(start,startline,end,endline,(unsigned char*)font6,inverse);
 499   2        }
 500   1        else if (index == 7)
 501   1        {
 502   2          Draw_BMP(start,startline,end,endline,(unsigned char*)font7,inverse);
 503   2        }
 504   1        else if (index == 8)
 505   1        {
 506   2          Draw_BMP(start,startline,end,endline,(unsigned char*)font8,inverse);
 507   2        }
 508   1        else if (index == 9)
 509   1        {
 510   2          Draw_BMP(start,startline,end,endline,(unsigned char*)font9,inverse);
 511   2        }
 512   1      }
 513          
 514          void display_TIB(unsigned char start,unsigned char startline,unsigned char end,unsigned char endline, unsi
             -gned char index,unsigned char inverse)
 515          {
 516   1        if (index == 0)
 517   1        {
 518   2          Draw_BMP(start,startline,end,endline,(unsigned char*)TIB_0,inverse);
 519   2        }
 520   1        else if (index == 1)
 521   1        {
 522   2          Draw_BMP(start,startline,end,endline,(unsigned char*)TIB_1,inverse);
 523   2        }
 524   1        else if (index == 2)
 525   1        {
 526   2          Draw_BMP(start,startline,end,endline,(unsigned char*)TIB_2,inverse);
 527   2        }
 528   1        else if (index == 3)
 529   1        {
 530   2          Draw_BMP(start,startline,end,endline,(unsigned char*)TIB_3,inverse);
 531   2        }
 532   1        else if (index == 4)
 533   1        {
 534   2          Draw_BMP(start,startline,end,endline,(unsigned char*)TIB_4,inverse);
 535   2        }
 536   1        else if (index == 5)
 537   1        {
 538   2          Draw_BMP(start,startline,end,endline,(unsigned char*)TIB_5,inverse);
 539   2        }
 540   1        else if (index == 6)
 541   1        {
 542   2          Draw_BMP(start,startline,end,endline,(unsigned char*)TIB_6,inverse);
 543   2        }
 544   1        else if (index == 7)
 545   1        {
 546   2          Draw_BMP(start,startline,end,endline,(unsigned char*)TIB_7,inverse);
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 10  

 547   2        }
 548   1        else if (index == 8)
 549   1        {
 550   2          Draw_BMP(start,startline,end,endline,(unsigned char*)TIB_8,inverse);
 551   2        }
 552   1        else if (index == 9)
 553   1        {
 554   2          Draw_BMP(start,startline,end,endline,(unsigned char*)TIB_9,inverse);
 555   2        }
 556   1      }
 557          
 558          void display_cnt_stage_cnt(unsigned long cnt,unsigned char isdisplay)
 559          {
 560   1        
 561   1        unsigned char i;
 562   1        unsigned long temp;
 563   1        unsigned char nextdisplay=0; 
 564   1        unsigned char start_index=0;
 565   1        if (isdisplay == 0)
 566   1        {
 567   2          OLED_CLS_Windows(0,2,64,4);
 568   2          return;
 569   2        }
 570   1        temp = cnt;
 571   1        if (sysinfo.numtype == ARABNUM)
 572   1        {
 573   2          #define CNT_START_ARABNUM 0
 574   2          #define ARABNUM_SIZE  16
 575   2          start_index = CNT_START_ARABNUM;
 576   2          
 577   2          i = getdiv(temp,1000);
 578   2          temp = getremainder(temp,1000);
 579   2          if ((nextdisplay == 1)||(i != 0))
 580   2          {
 581   3            nextdisplay = 1;
 582   3            display_ARA(start_index,1,start_index+ARABNUM_SIZE,4,i,0);
 583   3            start_index+=ARABNUM_SIZE;
 584   3          }
 585   2          else
 586   2          {
 587   3            start_index+=ARABNUM_SIZE>>1;
 588   3          }
 589   2          
 590   2          i = getdiv(temp,100);
 591   2          temp = getremainder(temp,100);
 592   2          if ((nextdisplay == 1)||(i != 0))
 593   2          {
 594   3            nextdisplay = 1;
 595   3            display_ARA(start_index,1,start_index+ARABNUM_SIZE,4,i,0);
 596   3            start_index+=ARABNUM_SIZE;
 597   3          }
 598   2          else
 599   2          {
 600   3            start_index+=ARABNUM_SIZE>>1;
 601   3          }
 602   2          
 603   2          i = getdiv(temp,10);
 604   2          temp = getremainder(temp,10);
 605   2          if ((nextdisplay == 1)||(i != 0))
 606   2          {
 607   3            nextdisplay = 1;
 608   3            display_ARA(start_index,1,start_index+ARABNUM_SIZE,4,i,0);
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 11  

 609   3            start_index+=ARABNUM_SIZE;
 610   3          }
 611   2          else
 612   2          {
 613   3            start_index+=ARABNUM_SIZE>>1;
 614   3          }
 615   2          
 616   2          i = temp;
 617   2          display_ARA(start_index,1,start_index+ARABNUM_SIZE,4,i,0);
 618   2        }
 619   1        else
 620   1        {
 621   2          #define CNT_START_TIBENUM 0
 622   2          #define TIBENUM_SIZE  16
 623   2          start_index = CNT_START_TIBENUM;
 624   2          
 625   2          i = getdiv(temp,1000);
 626   2          temp = getremainder(temp,1000);
 627   2          if ((nextdisplay == 1)||(i != 0))
 628   2          {
 629   3            display_TIB(start_index,1,start_index+TIBENUM_SIZE,4,i,0);
 630   3            nextdisplay = 1;
 631   3            start_index+=TIBENUM_SIZE;
 632   3          }
 633   2          else
 634   2            start_index+=TIBENUM_SIZE>>1;
 635   2          
 636   2          i = getdiv(temp,100);
 637   2          temp = getremainder(temp,100);
 638   2          if ((nextdisplay == 1)||(i != 0))
 639   2          {
 640   3            display_TIB(start_index,1,start_index+TIBENUM_SIZE,4,i,0);
 641   3            nextdisplay = 1;
 642   3            start_index+=TIBENUM_SIZE;
 643   3          }
 644   2          else
 645   2            start_index+=TIBENUM_SIZE>>1;
 646   2          
 647   2          i = getdiv(temp,10);
 648   2          temp = getremainder(temp,10);
 649   2          if ((nextdisplay == 1)||(i != 0))
 650   2          {
 651   3            display_TIB(start_index,1,start_index+TIBENUM_SIZE,4,i,0);
 652   3            nextdisplay = 1;
 653   3            start_index+=TIBENUM_SIZE;
 654   3          }
 655   2          else
 656   2            start_index+=TIBENUM_SIZE>>1;
 657   2          
 658   2          i = temp;
 659   2          display_TIB(start_index,1,start_index+TIBENUM_SIZE,4,i,0);
 660   2        }
 661   1      }
 662          
 663          double  Bandgap_Voltage,VDD_Voltage,BAT_Power_Voltage;      //please always use "double" mode for this
 664          unsigned  char xdata ADCdataH[5], ADCdataL[5];
 665          int ADCsumH=0, ADCsumL=0;
 666          unsigned char ADCavgH,ADCavgL;
 667          #define     READ_UID          0x04
 668          void READ_BANDGAP(void)
 669          {
 670   1          UINT8 BandgapHigh,BandgapLow,BandgapMark;
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 12  

 671   1          double Bandgap_Value,Bandgap_Voltage_Temp;
 672   1        
 673   1          BAT_Power_Voltage = 0;
 674   1          VDD_Voltage = 0;
 675   1          Bandgap_Voltage = 0;
 676   1        
 677   1          set_IAPEN;
 678   1          IAPCN = READ_UID;
 679   1          IAPAL = 0x0d;
 680   1          IAPAH = 0x00;
 681   1          set_IAPGO;
 682   1          BandgapLow = IAPFD;
 683   1          BandgapMark = BandgapLow&0xF0;
 684   1            
 685   1          if (BandgapMark==0x80)
 686   1          {
 687   2              BandgapLow = BandgapLow&0x0F;
 688   2              IAPAL = 0x0C;
 689   2              IAPAH = 0x00;
 690   2              set_IAPGO;
 691   2              BandgapHigh = IAPFD;
 692   2              Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 693   2              Bandgap_Voltage_Temp = Bandgap_Value*3/4;
 694   2              Bandgap_Voltage = Bandgap_Voltage_Temp - 33;      //the actually banggap voltage value is similar this va
             -lue.
 695   2          }
 696   1          if (BandgapMark==0x00)
 697   1          {
 698   2              BandgapLow = BandgapLow&0x0F;
 699   2              IAPAL = 0x0C;
 700   2              IAPAH = 0x00;
 701   2              set_IAPGO;
 702   2              BandgapHigh = IAPFD;
 703   2              Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 704   2              Bandgap_Voltage= Bandgap_Value*3/4;
 705   2          }
 706   1          if (BandgapMark==0x90)
 707   1          {
 708   2              IAPAL = 0x0E;
 709   2              IAPAH = 0x00;
 710   2              set_IAPGO;
 711   2              BandgapHigh = IAPFD;
 712   2              IAPAL = 0x0F;
 713   2              IAPAH = 0x00;
 714   2              set_IAPGO;
 715   2              BandgapLow = IAPFD;
 716   2              BandgapLow = BandgapLow&0x0F;
 717   2              Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 718   2              Bandgap_Voltage= Bandgap_Value*3/4;
 719   2          }
 720   1          clr_IAPEN;
 721   1      }
 722          
 723          void Get_Power_Value(void)
 724          { 
 725   1          double bgvalue;
 726   1          unsigned int i;
 727   1          clr_EA;
 728   1          Enable_ADC_BandGap;                       
 729   1          CKDIV = 0x02;                             // IMPORTANT!! Modify system clock to 4MHz ,then add the ADC sampling clock 
             -base to add the sampling timing.
 730   1          for(i=0;i<5;i++)                          // All following ADC detect timing is 200uS run under 4MHz.
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 13  

 731   1          {
 732   2              clr_ADCF;
 733   2              set_ADCS;                               
 734   2              while(ADCF == 0);
 735   2              ADCdataH[i] = ADCRH;
 736   2              ADCdataL[i] = ADCRL;
 737   2          }   
 738   1          CKDIV = 0x00;                             // After ADC sampling, modify system clock back to 16MHz to run next code.
 739   1          Disable_ADC;
 740   1          for(i=2;i<5;i++)                          // use the last 3 times data to make average 
 741   1          {
 742   2            ADCsumH = ADCsumH + ADCdataH[i];
 743   2            ADCsumL = ADCsumL + ADCdataL[i];
 744   2          }       
 745   1          ADCavgH = ADCsumH/3;
 746   1          ADCavgL = ADCsumL/3;
 747   1          bgvalue = (ADCavgH<<4) + ADCavgL;
 748   1          set_EA;
 749   1          VDD_Voltage = (0x1000/bgvalue)*Bandgap_Voltage;
 750   1          printf ("\r\n VDD voltage = %0.4f", VDD_Voltage); 
 751   1          
 752   1          ADCsumH = 0;
 753   1          ADCsumL = 0;
 754   1          //bat
 755   1          clr_EA;
 756   1          Enable_ADC_AIN3;
 757   1          CKDIV = 0x02;
 758   1          for(i=0;i<5;i++)                          // All following ADC detect timing is 200uS run under 4MHz.
 759   1          {
 760   2              clr_ADCF;
 761   2              set_ADCS;                               
 762   2              while(ADCF == 0);
 763   2              ADCdataH[i] = ADCRH;
 764   2              ADCdataL[i] = ADCRL;
 765   2          }   
 766   1          CKDIV = 0x00;
 767   1          Disable_ADC;
 768   1          for(i=2;i<5;i++)                          // use the last 3 times data to make average 
 769   1          {
 770   2            ADCsumH = ADCsumH + ADCdataH[i];
 771   2            ADCsumL = ADCsumL + ADCdataL[i];
 772   2          }       
 773   1          ADCavgH = ADCsumH/3;
 774   1          ADCavgL = ADCsumL/3;
 775   1          bgvalue = (ADCavgH<<4) + ADCavgL;
 776   1          bgvalue = bgvalue * 2;
 777   1          set_EA;
 778   1          if (BAT_Power_Voltage == 0)
 779   1          {
 780   2            BAT_Power_Voltage = (bgvalue/0x1000)*VDD_Voltage;
 781   2          }
 782   1          else
 783   1          {
 784   2            BAT_Power_Voltage = BAT_Power_Voltage * 0.8;
 785   2            BAT_Power_Voltage = BAT_Power_Voltage + (bgvalue/0x1000)*VDD_Voltage * 0.2;
 786   2          }
 787   1          printf ("\r\n BAT voltage = %0.4f", BAT_Power_Voltage); 
 788   1          
 789   1          ADCsumH = 0;
 790   1          ADCsumL = 0;
 791   1      }
 792          
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 14  

 793          unsigned char getbatlever(unsigned char ischarging)
 794          {
 795   1        unsigned char temp;
 796   1        if (ischarging == 1)
 797   1        {
 798   2          BAT_Power_Voltage -= 50;
 799   2        }
 800   1        {
 801   2          if (BAT_Power_Voltage < (BAT_LEVEL_0 - 50))
 802   2          {
 803   3            //0
 804   3            temp = 0;
 805   3          }
 806   2          else if ((BAT_Power_Voltage > (BAT_LEVEL_0 + 50)) && (BAT_Power_Voltage < (BAT_LEVEL_1 - 50)))
 807   2          {
 808   3            //1
 809   3            temp = 1;
 810   3          }
 811   2          else if ((BAT_Power_Voltage > (BAT_LEVEL_1 + 50)) && (BAT_Power_Voltage < (BAT_LEVEL_2 - 50)))
 812   2          {
 813   3            //2
 814   3            temp = 2;
 815   3          }
 816   2          else if (BAT_Power_Voltage > (BAT_LEVEL_1 + 50))
 817   2          {
 818   3            //3
 819   3            temp = 3;
 820   3          }
 821   2      //    printf("t/b=%d,%d",temp,batlevel);
 822   2          if (temp != batlevel)
 823   2          {
 824   3            bat_change_cnt++;
 825   3            if (bat_change_cnt >= 50)
 826   3            {
 827   4              if (ischarging == 1)
 828   4              {
 829   5                if (temp > batlevel)
 830   5                {
 831   6                  batlevel = temp;
 832   6                }   
 833   5                else
 834   5                {
 835   6                  temp = batlevel;
 836   6                }     
 837   5              }
 838   4              else
 839   4              {
 840   5                if (temp < batlevel)
 841   5                {
 842   6                  batlevel = temp;
 843   6                }
 844   5                else
 845   5                {
 846   6                  temp = batlevel;
 847   6                }
 848   5              }
 849   4              bat_change_cnt = 0;
 850   4            }
 851   3            else
 852   3            {
 853   4              temp = 0xFF;
 854   4            }
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 15  

 855   3          }
 856   2          else
 857   2          {
 858   3            temp = 0xFF;
 859   3            bat_change_cnt = 0;
 860   3          }
 861   2        }
 862   1        return temp;
 863   1      }
 864          
 865          void display_baticonlevel(unsigned char level)
 866          {
 867   1        unsigned char *buf;
 868   1        if(level == 0)
 869   1          buf = (unsigned char *)baticon_0;
 870   1        else if (level == 1)
 871   1          buf = (unsigned char *)baticon_1;
 872   1        else if (level == 2)
 873   1          buf = (unsigned char *)baticon_2;
 874   1        else if (level == 3)
 875   1          buf = (unsigned char *)baticon_3;
 876   1        else
 877   1        {
 878   2          printf("level error=%d\r\n",level);
 879   2          return;
 880   2        }
 881   1        isdisplaybaticon = 1;
 882   1        Draw_BMP(64-24,0,64,1,buf,0);
 883   1      }
 884          
 885          void display_baticon(void)
 886          {
 887   1        unsigned char level;
 888   1        level = getbatlever(0);
 889   1        if (level != 0xFF)
 890   1        {
 891   2          if (batlevel != level)
 892   2          {
 893   3            batlevel = level;
 894   3            display_baticonlevel(batlevel);
 895   3          }
 896   2          sysinfo.lastpower = level;
 897   2        }
 898   1      }
 899          
 900          void Cnt_Stage(void)
 901          {   
 902   1        if (sysinfo.isneedinitstage == 1)
 903   1        {
 904   2          sysinfo.isneedinitstage = 0;
 905   2          isdisplaybaticon = 0;
 906   2          display_cnt_stage_cnt(sysinfo.totalcnt,1);
 907   2          while (sysinfo.lastpower == 0xFF)
 908   2          {
 909   3            isdisplaybaticon = 0;
 910   3            sysinfo.lastpower = getbatlever(0);     
 911   3          }
 912   2          batlevel = sysinfo.lastpower;
 913   2          display_baticonlevel(sysinfo.lastpower);
 914   2          
 915   2          while(GETKEY == 0);
 916   2        }
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 16  

 917   1      
 918   1        display_baticon();
 919   1      
 920   1        if (keytype != NULLKEY)
 921   1        {
 922   2          if (keytype == SHORTKEY)
 923   2          {
 924   3            sysinfo.totalcnt++;
 925   3            if (sysinfo.totalcnt > 9999)
 926   3            {
 927   4              sysinfo.totalcnt = 0;
 928   4              display_cnt_stage_cnt(0,0); 
 929   4            }
 930   3            display_cnt_stage_cnt(sysinfo.totalcnt,1);
 931   3          }
 932   2          else if (keytype == LONGKEY_5S)
 933   2          {
 934   3            sysinfo.sysloop = RST_CNT;
 935   3            sysinfo.isneedinitstage = 1;
 936   3            stage_loopcnt = 0;
 937   3            OLED_CLS_Windows(0,0,64,2);
 938   3            display_cnt_stage_cnt(0,0);     
 939   3          }
 940   2          keytype = NULLKEY;
 941   2        }
 942   1      }
 943          
 944          
 945          void display_rst_cnt_stage_1(unsigned char isdisplay,unsigned char inverse)
 946          {
 947   1      //  char i;
 948   1      //  char * en = "RST";
 949   1      //  char * en1 = "CNT";
 950   1        if (sysinfo.language == ENGLISH)
 951   1        {
 952   2          if (isdisplay == 1)
 953   2          {
 954   3      //      for (i=0;i<3;i++)
 955   3      //      {
 956   3      //        Draw_BMP(6+i*8,0,8+6 + i*8,2,font_A_Z + (en[i]-'A')*16);
 957   3      //        Draw_BMP(32+ i*8,0,8+32+ i*8,2,font_A_Z + (en1[i]-'A')*16);
 958   3      //      }
 959   3            Draw_BMP(6,0,14,2,(unsigned char *)font_R,inverse);
 960   3            Draw_BMP(32,0,40,2,(unsigned char *)font_C,inverse);
 961   3            Draw_BMP(14,0,22,2,(unsigned char *)font_S,inverse);
 962   3            Draw_BMP(40,0,48,2,(unsigned char *)font_N,inverse);
 963   3            Draw_BMP(22,0,30,2,(unsigned char *)font_T,inverse);
 964   3            Draw_BMP(48,0,56,2,(unsigned char *)font_T,inverse);
 965   3          }
 966   2          else
 967   2          {
 968   3            OLED_CLS_Windows(6,0,56,2);
 969   3          }   
 970   2        }
 971   1        else
 972   1        {
 973   2          if (isdisplay == 1)
 974   2          {
 975   3            Draw_BMP(16,0,16+16,2,(unsigned char *)font_CHN_GUI,inverse);
 976   3            Draw_BMP(32,0,32+16,2,(unsigned char *)font_CHN_LING,inverse);
 977   3          }
 978   2          else
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 17  

 979   2          {
 980   3            OLED_CLS_Windows(16,0,48,2);
 981   3          }
 982   2        }
 983   1      }
 984          void display_rst_cnt_stage_yes(unsigned char isdisplay,unsigned char inverse)
 985          {
 986   1        if (sysinfo.language == ENGLISH)
 987   1        {
 988   2          if (isdisplay == 1)
 989   2          {
 990   3            Draw_BMP(20,0,20+8,2,(unsigned char *)font_Y,inverse);
 991   3            Draw_BMP(28,0,28+8,2,(unsigned char *)font_E,inverse);
 992   3            Draw_BMP(36,0,36+8,2,(unsigned char *)font_S,inverse);
 993   3          }
 994   2          else
 995   2          {
 996   3            OLED_CLS_Windows(20,0,44,2);
 997   3          }   
 998   2        }
 999   1        else  
1000   1        {
1001   2          if (isdisplay == 1)
1002   2          {
1003   3            Draw_BMP(24,0,24+16,2,(unsigned char *)font_CHN_SHI,inverse);
1004   3          }
1005   2          else
1006   2          {
1007   3            OLED_CLS_Windows(24,0,24+16,2);
1008   3          } 
1009   2        }
1010   1      }
1011          void display_rst_cnt_stage_no(unsigned char isdisplay,unsigned char inverse)
1012          {
1013   1        if (sysinfo.language == ENGLISH)
1014   1        {
1015   2          if (isdisplay == 1)
1016   2          {
1017   3            Draw_BMP(24,2,24+8,4,(unsigned char *)font_N,inverse);
1018   3            Draw_BMP(32,2,32+8,4,(unsigned char *)font_O,inverse);
1019   3          }
1020   2          else
1021   2          {
1022   3            OLED_CLS_Windows(24,2,40,4);
1023   3          }   
1024   2        }
1025   1        else  
1026   1        { 
1027   2          if (isdisplay == 1)
1028   2          {
1029   3            Draw_BMP(24,2,24+16,4,(unsigned char *)font_CHN_FOU,inverse);
1030   3          }
1031   2          else
1032   2          {
1033   3            OLED_CLS_Windows(24,2,24+16,4);
1034   3          }
1035   2        } 
1036   1      }
1037          void Rst_Cnt_Stage(void)
1038          {
1039   1        if (sysinfo.isneedinitstage == 1)
1040   1        {
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 18  

1041   2          sysinfo.isneedinitstage = 0;
1042   2          display_rst_cnt_stage_yes(1,1);
1043   2          display_rst_cnt_stage_no(1,0);
1044   2          stage_loopcnt = YES;
1045   2        }
1046   1        if (keytype != NULLKEY)
1047   1        {
1048   2          if (keytype == SHORTKEY)
1049   2          {
1050   3            if (stage_loopcnt == YES)
1051   3            {
1052   4              display_rst_cnt_stage_yes(1,0);
1053   4              display_rst_cnt_stage_no(1,1);
1054   4              stage_loopcnt = NO;
1055   4            }
1056   3            else
1057   3            {
1058   4              display_rst_cnt_stage_yes(1,1);
1059   4              display_rst_cnt_stage_no(1,0);
1060   4              stage_loopcnt = YES;
1061   4            }
1062   3          }
1063   2          else if (keytype == LONGKEY_2S)
1064   2          {
1065   3            if (stage_loopcnt == 0)//yes
1066   3              sysinfo.totalcnt = 0;
1067   3            sysinfo.sysloop = CNT_STAGE;
1068   3            stage_loopcnt = 0;
1069   3            sysinfo.isneedinitstage = 1;
1070   3            display_rst_cnt_stage_yes(0,0);
1071   3            display_rst_cnt_stage_no(0,0);      
1072   3          }
1073   2          else if (keytype == LONGKEY_12S)
1074   2          {
1075   3            display_rst_cnt_stage_yes(0,0);
1076   3            display_rst_cnt_stage_no(0,0);  
1077   3            sysinfo.sysloop = SYSINIT;
1078   3            stage_loopcnt = 0;
1079   3            sysinfo.isneedinitstage = 1;
1080   3          }
1081   2          keytype = NULLKEY;
1082   2        }
1083   1      }
1084          
1085          #if POWER_WAKEUP
1086          void display_baticonlevel_charging(unsigned char level)
1087          {
1088   1        unsigned char *buf;
1089   1        if(level == 0)
1090   1          buf = (unsigned char*)chargeicon_0;
1091   1        else if (level == 1)
1092   1          buf = (unsigned char*)chargeicon_1;
1093   1        else if (level == 2)
1094   1          buf = (unsigned char*)chargeicon_2;
1095   1        else if (level == 3)
1096   1          buf = (unsigned char*)chargeicon_3;
1097   1        else
1098   1        {
1099   2          printf("level error=%d\r\n",level);
1100   2          return;
1101   2        }
1102   1        isdisplaybaticon = 1;
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 19  

1103   1        Draw_BMP(16,1,16+32,3,buf,0);
1104   1      }
1105          
1106          
1107          void Sys_Charge_Stage(void)
1108          {
1109   1        unsigned char level;
1110   1        if (sysinfo.isneedinitstage == 1)
1111   1        {
1112   2          sysinfo.isneedinitstage = 0;  
1113   2          OLED_CLS_Windows(0,0,64,4);
1114   2          while (sysinfo.lastpower == 0xFF)
1115   2          {
1116   3            isdisplaybaticon = 0;
1117   3            sysinfo.lastpower = getbatlever(1);     
1118   3          }
1119   2          batlevel = sysinfo.lastpower;
1120   2          display_baticonlevel_charging(sysinfo.lastpower);
1121   2          blinktime = 0;
1122   2          bat_charging_level = batlevel;
1123   2        }
1124   1        if (keytype != NULLKEY)
1125   1        {
1126   2          keytype = NULLKEY;
1127   2        }
1128   1        //blink
1129   1        if (blinktime == (BLINK_H+BLINK_L))
1130   1        {
1131   2          blinktime = 0;
1132   2          level = getbatlever(1);
1133   2          if (level != 0xFF)
1134   2          {
1135   3            if (batlevel != level)
1136   3            {
1137   4              batlevel = level;
1138   4              //display bat
1139   4              display_baticonlevel_charging(batlevel);
1140   4            }
1141   3            sysinfo.lastpower = level;  
1142   3          }
1143   2          else
1144   2          {
1145   3            bat_charging_level++;
1146   3            if (bat_charging_level > 3)
1147   3              bat_charging_level = sysinfo.lastpower;
1148   3            display_baticonlevel_charging(bat_charging_level);
1149   3          }
1150   2        }   
1151   1      }
1152          #endif
1153          void SysLoop(void)
1154          {
1155   1        switch(sysinfo.sysloop)
1156   1        {
1157   2          case SELECT_LANGUAGE:
1158   2            Select_Language();
1159   2            break;
1160   2          case SELECT_NUMTYPE:
1161   2            Select_NumType();
1162   2            break;
1163   2          case CNT_STAGE:
1164   2            Cnt_Stage();
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 20  

1165   2            break;
1166   2          case RST_CNT:
1167   2            Rst_Cnt_Stage();
1168   2            break;
1169   2          #if POWER_WAKEUP
1170   2          case SYS_CHARGE:
1171   2            Sys_Charge_Stage();
1172   2            break;
1173   2          #endif
1174   2          default:break;
1175   2        }
1176   1      }
1177          void PinInterrupt_ISR (void) interrupt 7
1178          {
1179   1        PIF = 0;
1180   1      }
1181          void EXT_INT0(void) interrupt 0
1182          {
1183   1        
1184   1      }
1185          
1186          void EXT_INT1(void) interrupt 2
1187          {
1188   1        
1189   1      }
1190          void P30_init(void){
1191   1        P30_Input_Mode;
1192   1        set_P3S_0;
1193   1      //  set_IT0;
1194   1      //  set_EX0;
1195   1      //  
1196   1      //  Enable_BIT0_RasingEdge_Trig;
1197   1        PICON|=0x04;PINEN&=0xFE;PIPEN|=0x01;
1198   1        Enable_INT_Port3;
1199   1        set_EPI;
1200   1        
1201   1        set_EA;
1202   1      }
1203          void exti1_init(void){
1204   1        P17_Input_Mode;
1205   1        set_P1S_7;
1206   1        set_EX1;
1207   1        set_EA;
1208   1      }
1209          void Enter_DPD(void)
1210          {
1211   1        //…Ë÷√P17∞¥º¸ªΩ–—
1212   1        P30_init();
1213   1        exti1_init();
1214   1        
1215   1        set_PD;
1216   1        
1217   1        PICON  = PICON & 0xFE;
1218   1              
1219   1        clr_EX0;
1220   1        clr_EX1;
1221   1        clr_EPI;
1222   1      }
1223          void main1 (void) 
1224          {
1225   1          double bgvalue;
1226   1          unsigned int i;
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 21  

1227   1      //  Set_All_GPIO_Quasi_Mode;
1228   1          Timer0_Init();
1229   1          InitialUART1_Timer3(115200);
1230   1        TI_1 = 1;
1231   1          READ_BANDGAP();
1232   1          printf ("\n BG ROMMAP = %e",Bandgap_Voltage); 
1233   1        
1234   1          while (1)
1235   1          {
1236   2              Enable_ADC_BandGap;                       
1237   2              CKDIV = 0x02;                             // IMPORTANT!! Modify system clock to 4MHz ,then add the ADC sampling cloc
             -k base to add the sampling timing.
1238   2              for(i=0;i<5;i++)                          // All following ADC detect timing is 200uS run under 4MHz.
1239   2              {
1240   3                  clr_ADCF;
1241   3                  set_ADCS;                               
1242   3                  while(ADCF == 0);
1243   3                  ADCdataH[i] = ADCRH;
1244   3                  ADCdataL[i] = ADCRL;
1245   3              }   
1246   2              CKDIV = 0x00;                             // After ADC sampling, modify system clock back to 16MHz to run next code.
1247   2              Disable_ADC;
1248   2              for(i=2;i<5;i++)                          // use the last 3 times data to make average 
1249   2              {
1250   3                ADCsumH = ADCsumH + ADCdataH[i];
1251   3                ADCsumL = ADCsumL + ADCdataL[i];
1252   3              }       
1253   2              ADCavgH = ADCsumH/3;
1254   2              ADCavgL = ADCsumL/3;
1255   2              bgvalue = (ADCavgH<<4) + ADCavgL;
1256   2              VDD_Voltage = (0x1000/bgvalue)*Bandgap_Voltage;
1257   2              printf ("\r\n VDD voltage = %e", VDD_Voltage); 
1258   2              
1259   2              ADCsumH = 0;
1260   2              ADCsumL = 0;
1261   2              //bat
1262   2              Enable_ADC_AIN3;
1263   2              CKDIV = 0x02;
1264   2              for(i=0;i<5;i++)                          // All following ADC detect timing is 200uS run under 4MHz.
1265   2              {
1266   3                  clr_ADCF;
1267   3                  set_ADCS;                               
1268   3                  while(ADCF == 0);
1269   3                  ADCdataH[i] = ADCRH;
1270   3                  ADCdataL[i] = ADCRL;
1271   3              }   
1272   2              CKDIV = 0x00;
1273   2              Disable_ADC;
1274   2              for(i=2;i<5;i++)                          // use the last 3 times data to make average 
1275   2              {
1276   3                ADCsumH = ADCsumH + ADCdataH[i];
1277   3                ADCsumL = ADCsumL + ADCdataL[i];
1278   3              }       
1279   2              ADCavgH = ADCsumH/3;
1280   2              ADCavgL = ADCsumL/3;
1281   2              bgvalue = (ADCavgH<<4) + ADCavgL;
1282   2              bgvalue = bgvalue * 2;
1283   2              VDD_Voltage = (bgvalue/0x1000)*VDD_Voltage;
1284   2              printf ("\r\n VDD voltage = %e", VDD_Voltage); 
1285   2              
1286   2              ADCsumH = 0;
1287   2              ADCsumL = 0;
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 22  

1288   2          }
1289   1      }
1290          
1291          void main(void)
1292          {
1293   1        while(1)
1294   1        {
1295   2      //    Set_All_GPIO_Quasi_Mode;
1296   2          Timer0_Init();
1297   2          OLED_Init();
1298   2          OLED_Clear();
1299   2          KeyInit();
1300   2          //read sys struct from ldrom
1301   2          getdata(SysStructLen,(unsigned char *)&sysinfo);
1302   2          stage_loopcnt = 0;
1303   2          sysinfo.isneedinitstage = 1;
1304   2          powercnt = 0;
1305   2          isdisplaybaticon = 0;
1306   2          #if UART_TEST
1307   2          InitialUART1_Timer3(115200);
1308   2          TI_1 = 1;
1309   2          #endif
1310   2          READ_BANDGAP();
1311   2          Get_Power_Value();
1312   2      //    while(1)
1313   2      //    {
1314   2      //      if (get_battery_time >= 200)
1315   2      //      {
1316   2      //        Get_Power_Value();
1317   2      //        get_battery_time = 0;
1318   2      //      }
1319   2      //    }
1320   2          while(!GETKEY);
1321   2          printf("start\r\n");
1322   2          while(1)
1323   2          {
1324   3            KeyScan();
1325   3            
1326   3            if ((sysinfo.isinitsys != 0xA5)||(sysinfo.sysloop == SYSINIT))
1327   3            {
1328   4              //clr sysinfo
1329   4              sysinfo.language = CHINESE;
1330   4              sysinfo.numtype = ARABNUM;
1331   4              sysinfo.totalcnt = 0;
1332   4              sysinfo.isinitsys = 0xA5;
1333   4              sysinfo.sysloop = SELECT_LANGUAGE;
1334   4              OLED_Set_Pos(7,1);
1335   4              Draw_BMP(12,1,12+8,3,(unsigned char *)font_K,0);
1336   4              Draw_BMP(20,1,20+16,3,(unsigned char *)font_CHN_SAN,0);
1337   4              Draw_BMP(36,1,36+8,3,(unsigned char *)font_W,0);
1338   4              Draw_BMP(44,1,44+8,3,(unsigned char *)font_A,0);
1339   4              
1340   4              powercnt = 0;
1341   4              while(powercnt<400);
1342   4              powercnt=0;
1343   4              sysinfo.isneedinitstage = 1;
1344   4              
1345   4              OLED_CLS_Windows(12,1,52,3);
1346   4            }
1347   3            SysLoop();
1348   3      
1349   3            if (get_battery_time >= 40)
C51 COMPILER V9.54   COUNT                                                                 12/20/2019 18:51:13 PAGE 23  

1350   3            {
1351   4              Get_Power_Value();
1352   4              get_battery_time = 0;
1353   4            }
1354   3            //power mode
1355   3            if (powercnt >= POWER_CNT1)
1356   3            {
1357   4              printf("sleep\r\n");
1358   4              OLED_Display_Off();
1359   4              if (sysinfo.sysloop == RST_CNT)
1360   4                sysinfo.sysloop = CNT_STAGE;
1361   4              savedata(SysStructLen,(unsigned char *)&sysinfo);
1362   4      
1363   4              Set_All_GPIO_Quasi_Mode;
1364   4              clr_ADCEN;
1365   4              clr_TR0;
1366   4              
1367   4              P14_OpenDrain_Mode;
1368   4              P14 = 0;
1369   4              Enter_DPD();
1370   4              powercnt = 0;
1371   4              set_TR0;
1372   4              printf("wakeup\r\n");
1373   4              break;
1374   4            }
1375   3          }
1376   2        }
1377   1      }
1378          
1379          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6806    ----
   CONSTANT SIZE    =    125    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =     45      91
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
